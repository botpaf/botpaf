{-# LANGUAGE OverloadedStrings #-}
module Main where

-- import Data.Foldable ( for_ )

import Data.Text (Text)
import qualified Data.Text as Text
import qualified Data.Text.IO as Text

import Data.Foldable ( asum, for_ )
import Control.Monad ( unless )

import Lens.Micro.Platform ( (&), (^..) )

import Control.Concurrent.Async ( Async, async )
import Control.Concurrent.STM ( atomically, TQueue, newTQueueIO, readTQueue, writeTQueue, retry, readTVar, registerDelay, STM )

import Bot.Config

import Twitch.IRCv32

data Bot
  = Bot
    { botConfig   :: BotConfig
    , fromIrcChan :: TQueue Message
    , toIrcChan   :: TQueue Say
    , ircThread   :: Maybe (Async ())
    , botTimer    :: STM ()
    }

--------------------------------------------------------------------------------

main :: IO ()
main = do
  config  <- getBotConfig "botpaf.ini"
  fromIrc <- newTQueueIO
  toIrc   <- newTQueueIO
  thread  <- async $ connect config fromIrc toIrc
  -- timer   <- newTimer
  main' Bot
    { botConfig   = config
    , fromIrcChan = fromIrc
    , toIrcChan   = toIrc
    , ircThread   = Just thread
    , botTimer    = noTimer }

-- Events ----------------------------------------------------------------------

data Event
  = IrcEvent Message
  | TimerEvent

getEvent :: Bot -> IO Event
getEvent bot = atomically $ asum
  [ IrcEvent   <$> readTQueue (fromIrcChan bot)
  , TimerEvent <$  botTimer bot
  ]

main' :: Bot -> IO ()
main' bot = do
  ev <- getEvent bot
  case ev of
    IrcEvent msg -> resume =<< doIrcEvent bot msg
    TimerEvent   ->  main' =<< doTimerEvent bot
  where
    resume Nothing     = pure ()
    resume (Just bot') = main' bot'

-- IRC events ------------------------------------------------------------------

-- | Handle events generated by the IRC connection.
doIrcEvent :: Bot -> Message -> IO (Maybe Bot)
doIrcEvent bot event =
  case event of
    Privmsg _ _ _ _ -> doMsg bot event
    _               -> Just <$> doEchoRawMsg bot event

doEchoRawMsg :: Bot -> Message -> IO Bot
doEchoRawMsg bot msg = do
  Text.putStrLn $ "NoParse: " <> (msg & show & Text.pack)
  return bot

doMsg :: Bot -> Message -> IO (Maybe Bot)
doMsg bot msg = do
  let [room,text] = msg ^.. (msgRoom . roomName <> msgText)
  let me = Text.stripPrefix "!echo " text
  for_ me (say bot room . (\e -> msg ^. msgUser . userName <> ": " <> e))
  if ("!quit" `Text.isPrefixOf` text)
  then do
    Text.putStrLn $ "received quit signal in " <> room
    return Nothing
  else do
    Text.putStrLn $ "Parsed: " <> (Text.pack $ show msg)
    return $ Just bot

say :: Bot -> Text -> Text -> IO ()
say bot room text = atomically $ writeTQueue (toIrcChan bot) $ Say room text

-- | Handle timer events.
doTimerEvent :: Bot -> IO Bot
doTimerEvent bot = do
  Text.putStrLn "ding!"
  t <- newTimer
  return $ bot { botTimer = t }

-- Timers

noTimer :: STM ()
noTimer = retry

newTimer :: IO (STM ())
newTimer = do
  v <- registerDelay 5000000
  return $ flip unless retry =<< readTVar v
